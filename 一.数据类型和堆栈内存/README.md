# 数据类型和堆栈内存

## 8种数据类型
![8种数据类型](./imgs/8种数据类型.jpg)

1. 区分js中的8中数据类型。注意函数，数组等不是数据类型
2. 使用typeof进行类型判断的两个缺点：
* 1. typeof null === "object"
* 2. 数组，正则，日期等数据，使用typeof进行判断时得到的只是"object"，无法得到明确的数据类型。

### typeof为什么不能准确地检测数据类型
这与typeof的底层原理有关：
在计算机底层中，所有的数据类型值的存储都是按照二进制进行存储的。其中：
1. null -> 000000（null表示空，它在底层的存储对应的就是6个0，也就是000000）
2. 只要是对象类型(无论是普通对象还是数组对象等，除了函数其他对象都是以000开头)，所有的存储都是以000开头。
3. typeof检测的时候，是按照计算机存储的值来进行检测的。它检测null的时候，会发现以000开头，就把它当做object类型进行处理了。


### 判断是否是有效数字
使用isNaN来判断一个字符是否是有效数字，如果isNaN返回的是false，那么表示是有效数字，如果返回的是true，表示是NaN,也就是说不是数字。
```js
var str = "abc123"
console.log(isNaN(str[0])) // true
console.log(isNaN(str[3])) // false
```
### Symbol
1. Symbol无法通过new 来进行创建
因为Symbol创建的是一个基本类型的值，它是不涉及到引用的，也就是说它无法像构造函数一样，生成一个对象，然后把this的值指向这个对象。因此，创建Symbol时，直接调用`Symbol()`即可。
2. Symbol是唯一的。
```js
console.log(Symbol() === Symbol())  // false
```
3. 为了能够区分创建的Symbol，我们通常给`Symbol("aaa")`创建时添加标记，这个标记纯粹是用于区分，哪怕标记相同，他们也是不相等的。
4. 一般只有在给对象设置唯一的属性时，才会使用Symbol
5. **Symbol原型上的很多方法和属性都会在其他方法的原理中得到使用。**


### bigint 超大数字
前端数字的范围是[Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER]，也就是[-2^53,2^53]。如果超过这个数字的话就会不准确了。
```js
var a = Number.MAX_SAFE_INTEGER // 9007199254740991
console.log(a + 4)  // 9007199254740996  不准确了
```
因此为了准确性提出了超大数字。在数组后面加个n表示超大数字。
```js
console.log(9007199254740991n+4n)  // 9007199254740995n
```
注意：超大数字进行操作时，必须两个都是超大数字。
