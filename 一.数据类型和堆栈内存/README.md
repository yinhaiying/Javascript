# 数据类型和堆栈内存

## 8种数据类型
![8种数据类型](./imgs/8种数据类型.jpg)

1. 区分js中的8中数据类型。注意函数，数组等不是数据类型
2. 使用typeof进行类型判断的两个缺点：
* 1. typeof null === "object"
* 2. 数组，正则，日期等数据，使用typeof进行判断时得到的只是"object"，无法得到明确的数据类型。

### typeof为什么不能准确地检测数据类型
这与typeof的底层原理有关：
在计算机底层中，所有的数据类型值的存储都是按照二进制进行存储的。其中：
1. null -> 000000（null表示空，它在底层的存储对应的就是6个0，也就是000000）
2. 只要是对象类型(无论是普通对象还是数组对象等，除了函数其他对象都是以000开头)，所有的存储都是以000开头。
3. typeof检测的时候，是按照计算机存储的值来进行检测的。它检测null的时候，会发现以000开头，就把它当做object类型进行处理了。


### 判断是否是有效数字
使用isNaN来判断一个字符是否是有效数字，如果isNaN返回的是false，那么表示是有效数字，如果返回的是true，表示是NaN,也就是说不是数字。
```js
var str = "abc123"
console.log(isNaN(str[0])) // true
console.log(isNaN(str[3])) // false
```
### Symbol
1. Symbol无法通过new 来进行创建
因为Symbol创建的是一个基本类型的值，它是不涉及到引用的，也就是说它无法像构造函数一样，生成一个对象，然后把this的值指向这个对象。因此，创建Symbol时，直接调用`Symbol()`即可。
2. Symbol是唯一的。
```js
console.log(Symbol() === Symbol())  // false
```
3. 为了能够区分创建的Symbol，我们通常给`Symbol("aaa")`创建时添加标记，这个标记纯粹是用于区分，哪怕标记相同，他们也是不相等的。
4. 一般只有在给对象设置唯一的属性时，才会使用Symbol
5. **Symbol原型上的很多方法和属性都会在其他方法的原理中得到使用。**


### bigint 超大数字
前端数字的范围是[Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER]，也就是[-2^53,2^53]。如果超过这个数字的话就会不准确了。
```js
var a = Number.MAX_SAFE_INTEGER // 9007199254740991
console.log(a + 4)  // 9007199254740996  不准确了
```
因此为了准确性提出了超大数字。在数组后面加个n表示超大数字。
```js
console.log(9007199254740991n+4n)  // 9007199254740995n
```
注意：超大数字进行操作时，必须两个都是超大数字。

## 数据类型的区别——堆和栈

JS代码的常见运行环境：
1. 浏览器
2. Node
3. webview

### 浏览器是如何执行JS代码的

1. 浏览器能够运行JS代码，主要原因是会在计算机的内存当中，分配出一块内存，用来供代码执行。这部分内存被称作“栈内存”，也就是所谓的执行环境栈(Execution Context Stack，EC Stack)。
2. 浏览器在执行过程中，会区分是哪个区域下的代码在执行。为了区分是哪个区域下的代码执行(全局下的代码还是函数中的代码)，会产生一个执行上下文(Execution Context,EC)。
* EC(G) 全局执行上下文
3. 在执行过程中，会定义一些变量，这些变量都放在执行上下文的VO(variable object，变量对象)中。
4. 代码执行，分为三步，创建值，创建变量，给变量赋值(将变量和值关联起来)。
如下所所示，是一段代码在栈中的执行过程。
```js
var a = "123";
var b = a;
    b = 13;
console.log(a)

```
![数据结构和堆栈内存](./imgs/数据结构和堆栈内存1.png)
