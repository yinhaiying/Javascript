# 继承
JS本身是基于面向对象开发的编程语言。面向对象中的类的三大特点：
* 封装：类也是一个函数，把实现一个功能的代码进行封装，实现低耦合高内聚。

* 多态：重载和重写。
  重写：子类能够重写父类的方法(伴随着继承运行)
  重载：相同的方法由于参数或者返回值不同，具备不同的功能(JS中基本上不具备严格意义上的重载)。

* 继承：子类继承父类的方法。在JS语言当中它的继承和其他的编程语言不太一样。


## 继承的理解
```js
function Parent(){
    this.x = 10;
}

Parent.prototype.getX = function(){
    return this.x;
}

function Child(){
    this.y= 200;
}
Child.prototype.getY = function(){
    return this.y;
}

let c = new Child();
```
如上面的代码所示：c是`Child`类的实例，他只有自己身上的私有属性和公共方法。如下所示：
![实例](https://ftp.bmp.ovh/imgs/2021/03/cfe7877d310256c1.jpg)
现在我们希望它能够拥有`Parent`类身上的属性和公共方法。也就是实现继承。
1. 我们之前知道，查找属性时是按照原型链进行查找，也就是先查找`自身私有属性`，然后通过`__proto__`查找原型链上的属性(vm.Prototype)，然后查找原型的`__proto__`，知道查找到`Object.prototype === null`为止。我们现在想要使用`Parent`上的属性和方法，说明它的肯定在这条原型链上。
2. 什么东西能够拥有`Parent`的私有属性和公有方法。那就是`Parent`的实例。
3. 综上所述：我们需要将字类的原型链和父类的实例连接起来。
同时，我们实现继承需要注意两点：
1. 需要保留子类的私有属性和公共方法
2. 需要能够使用父类的私有属性和公共方法


**方法一：将实例`__proto__`指向父类的实例。**
将`__proto__`指向父类的实例，这样的话查找时沿着`__proto__`，进行查找就能够找到父类的私有属性和公共方法了，但是这里有个问题：
1. `__proto__`是每个实例对象的属性，因此每次继承时都需要指定一次`__proto__`肯定是不对的。
2. 修改了`__proto__`，那么就相当于断开了`Child.prototype`，那就拿不到子类身上的公共方法了。
因此，这种方法并不可行。
**方法二：将子类的原型Child.prototype指向父类的实例**
通过将子类的原型指向父类的实例，如下所示：
```js
function Parent(){
    this.x = 10;
}

Parent.prototype.getX = function(){
    return this.x;
}

function Child(){
    this.y= 200;
}
Child.prototype = new Parent();  // 原型继承，必须先设置原型，然后才能往原型上添加方法
Child.prototype.getY = function(){
    return this.y;
}
```
1. 通通过`__proto__`找到的`Child.prototype`就是父类的实例，因此拥有父类的方法和属性
2. 子类自身的私有属性不受影响，子类的原型上的方法必须在修改`Child.prototype`之后才能定义，相当于定义到父类的实例身上了，照样可以拿到。因此能够实现继承。




### 原型继承——让子类的原型能够指向父类的原型即可。


