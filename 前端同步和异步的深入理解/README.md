# 同步和异步

## 进程和线程
进程：程序。（浏览器打开一个页面，就会开辟一个进程）。
线程:干活的，用来处理任务的，一个线程同时只能处理一个任务。
**浏览器是多线程的**，也就是打开浏览器一个页面，会开辟多个线程，比如：
1. HTTP网络线程 用于资源文件的请求和加载。可能开辟多个HTTP网络线程
2. GUI渲染线程 用于页面自上而下渲染，最后绘制出页面
3. js渲染线程 专门用于渲染JS代码
... 
但是JS是单线程的：因为浏览器只会开辟一个js线程用来渲染js，之所以只开辟一个js线程，是因为js中可能涉及到DOM的操作，如果有多个js线程，那么如果其中一个删除DOM，一个更改DOM，就会产生冲突，导致页面渲染出现问题，因此，浏览器只会使用一个js线程来渲染js。也就是说对于Js来说只能一次干一件事，所以JS的本质是**同步**的（当前事情处理完成之后才能处理下一件事情）。

但是JS中是有异步编程的代码的，但是此处的异步编程也不是让其同时处理多件事情，只不过是结合浏览器的多线程性，再结合EventLoop事件循环机制，构建出来的异步效果。


**JS中常见的异步编程**
1. 定时器 设置定时器是同步的，而间隔Interval这么长时间后，触发绑定的方法执行这件事情是异步的。




### Event Loop
宏任务：定时器。
1. 在代码执行过程中，只要创建一个异步任务，则会把这个异步任务放置到Event Queue中。任务放置完成，不需要等待任务执行，主线程会继续
执行同步代码。
2. 对于定时器或者事件绑定等创建的异步任务来讲，放置到事件队列中，浏览器此时会开辟一个新的线程，也就是监听线程，监听定时器是否到达指定的时间。
3. 当同步任务执行完毕，主线程空闲下来，才会看Event Queue中是否存在等待任务，如果存在按照顺序，依次把等待任务拿出来，放到主线程中去执行。当主线程再次空闲下来后，再去Event Queue中进行查找...，我们把这个查找的过程叫做Event Loop事件循环机制。
4. 特殊说明。当同步任务没有执行完，或者主线程还没有空闲下来，此时哪怕有异步任务已经符合了执行条件，比如定时器到时间了，也不会执行异步任务，继续等待主线程空闲下来后才会去Event Queue中查找符合条件的异步任务。再次证明了JS是单线程的，一次只能处理一件事，而且所有事都是主线程处理的。
5. Event Loop的查找过程，先找微任务队列，如果微任务队列中有，则按照存放顺序获取并且执行（因为微任务一般不存在执行条件）。如果微任务中没有则再次去宏任务中查找，在宏任务队列中一般按照谁先到达执行条件，哪怕都到达执行条件了，也要按照先后顺序，先到达的就先把谁拿出来执行。

### 宏任务和微任务
宏任务和微任务是异步队列中任务的进一步细分，将一些需要等到执行条件才能放到主线程中执行的任务，比如定时器(需要等待interval时间)，事件绑定(需要等待事件触发)，ajax（需要等待返回结果），这些称为宏任务。将那些不需要等待执行条件，只要主线程空闲了就可以放入进去执行的称之为微任务队列。
宏任务：
1. 定时器
2. 事件绑定
3. ajax请求
微任务：
1. promsie
2. async/await

### async
async修饰符的作用：让一个函数返回一个Promise实例（默认都是成功状态，除非本身就是返回一个Promsie实例,最后返回结果以自定义promsie为准）
```js
async function fn(){
    return 10;
}
console.log(fn()); 
// Promise {<fulfilled>: 10}
//     __proto__: Promise
//    [[PromiseState]]: "fulfilled"
//    [[PromiseResult]]: 10
```
然而这并没有什么用，返回promise的方法很多，不需要使用async。async真正的作用是用于辅助await。

await:只能用于async修饰的函数。await可以使异步编程模拟出同步效果。await后面一般会放置一个promsie实例，其他的也行。
等待promsie状态为成功之后，获取成功的结果，然后才会执行函数体中await后面的代码。如果await后面的Promise的实例是失败的，
则不再执行后面的代码(即不再执行之前存放的微任务)，因为没有使用try catch捕捉错误，浏览器就会抛出异常信息。因此，await最好使用
try...catch捕捉错误。
await的异步性体现在：碰到await就会把它后面的代码放到异步队列中。
```js
function handle(){
    return new Promise(resolve => {
        setTimeout(() => {
            resolve("OK");
        },1000);
    })
}

async function fn1(){
    let result = await handle();  // 等待promise变为成功态，然后获取promsie的值。在此期间后面的代码都不会执行。
    console.log(result);
    let n = await 10;// 虽然await后面放的是10 ，肯定是成功的，但是下面的代码也不是立即执行。需要等到同步任务执行完毕
    console.log(n); // await本身是异步的，await后面的代码需要等待。
    let m = await Promise.resolve("HH");
    console.log(m);
}
fn1();
/* 
OK
10
HH
*/
```