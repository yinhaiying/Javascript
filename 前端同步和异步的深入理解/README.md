# 同步和异步

## 进程和线程
进程：程序。（浏览器打开一个页面，就会开辟一个进程）。
线程:干活的，用来处理任务的，一个线程同时只能处理一个任务。
**浏览器是多线程的**，也就是打开浏览器一个页面，会开辟多个线程，比如：
1. HTTP网络线程 用于资源文件的请求和加载。可能开辟多个HTTP网络线程
2. GUI渲染线程 用于页面自上而下渲染，最后绘制出页面
3. js渲染线程 专门用于渲染JS代码
... 
但是JS是单线程的：因为浏览器只会开辟一个js线程用来渲染js，之所以只开辟一个js线程，是因为js中可能涉及到DOM的操作，如果有多个js线程，那么如果其中一个删除DOM，一个更改DOM，就会产生冲突，导致页面渲染出现问题，因此，浏览器只会使用一个js线程来渲染js。也就是说对于Js来说只能一次干一件事，所以JS的本质是**同步**的（当前事情处理完成之后才能处理下一件事情）。

但是JS中是有异步编程的代码的，但是此处的异步编程也不是让其同时处理多件事情，只不过是结合浏览器的多线程性，再结合EventLoop事件循环机制，构建出来的异步效果。


**JS中常见的异步编程**
1. 定时器 设置定时器是同步的，而间隔Interval这么长时间后，触发绑定的方法执行这件事情是异步的。




### 异步队列中的宏任务和微任务
宏任务：定时器。
1. 在代码执行过程中，只要创建一个异步任务，则会把这个异步任务放置到Event Queue中。任务放置完成，不需要等待任务执行，主线程会继续
执行同步代码。
2. 对于定时器或者事件绑定等创建的异步任务来讲，放置到事件队列中，浏览器此时会开辟一个新的线程，也就是监听线程，监听定时器是否到达指定的时间。
3. 当同步任务执行完毕，主线程空闲下来，才会看Event Queue中是否存在等待任务，如果存在按照顺序，依次把等待任务拿出来，放到主线程中去执行。当主线程再次空闲下来后，再去Event Queue中进行查找...，我们把这个查找的过程叫做Event Loop事件循环机制。
4. 特殊说明。当同步任务没有执行完，或者主线程还没有空闲下来，此时哪怕有异步任务已经符合了执行条件，比如定时器到时间了，也不会执行异步任务，继续等待主线程空闲下来后才会去Event Queue中查找符合条件的异步任务。再次证明了JS是单线程的，一次只能处理一件事，而且所有事都是主线程处理的。