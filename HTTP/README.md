# HTTP

## HTTP/1.1

HTTP/1.x 虽然已经能解决绝大多数传输问题了，但是还是存在一些问题，比如：

1. 文本传输：http/1.x 中都是使用文本进行传输（传输体积大），而且不进行压缩。
2. 传输问题：必须加载完一个请求，才能发送第二次请求(虽然可以并发发送请求，但是之后再想发送请求，必须等到上一个请求返回完毕，才能进行下一次请求发送)
3. header 头非常长，最好进行压缩
4. 服务端无法主动 push(后来出现了 websocket)

## HTTP/2.0

HTTP/2.0 主要是针对 HTTP/1.x 存在的这四个问题，进行了改进：

1. 不再使用明文传输，而是使用二进制进行传输(二进制文件相比于之前的明文，进行了压缩，减小了传输体积)。
2. 单连接+帧。在 http1 中如果由多个数据进行传输，会建立多个连接进行请求，而在 http2 中使用单连接+帧，也就是只需要使用一个连接，请求时会将数据变成帧(类似于数据流打散)的形式，然后返回后进行重组。
3. 实现了多工通信。HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。举例来说，在一个 TCP 连接里面，服务器同时收到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送 A 请求已经处理好的部分， 接着回应 B 请求，完成后，再发送 A 请求剩下的部分。
4. 头部信息压缩
5. 服务器端主动 push

## HTTPS 协议

由于 HTTP 天生“明文”的特点，整个传输过程完全透明，任何人都能够在链路中截获、修改或者伪造请求/响应报文，数据具有不可信。因此，就诞生了为安全而生的 https 协议。
使用过 HTTPS 时，所有的 HTTP 请求和响应在发送到网络之前，都要进行加密，实际上就是在 HTTP 和 TCP 层之间新增了一个安全层 SSL/TSL，这个安全层提供了各种加密 API 用于给 HTTP 加密，这样的话每次 HTTP 发送数据，先经过 SSL/TSL 层尽心加密，然后才到达 TCP 层；返回数据时，TCP 的数据也要先经过 SSL/TSL 进行加密，然后才返回给 HTTP 层。

### 摘要算法(md5, sha1, sha2,sha1 256)：

摘要算法是把任意长度的数据，变成固定长度的数据。
比如 md5 就是把任意长度的数据，变成 32 位的数据。

### 对称加密算法

加密解密时使用相同的密钥。比如密钥为异或

10110100 原文
01110111 密钥
11000011 加密后的文本

解密：
11000011 加密后的文本
01110111 密钥
10110100 解密后的文本 和 10110100 原文 两者一致

### 非对称加密

非对称加密，存在两个密钥，一个叫"公钥"，一个叫“私钥”。

- 使用公钥加密 那么只能使用私钥进行解密
- 使用私钥加密 那么只能使用公钥解密
