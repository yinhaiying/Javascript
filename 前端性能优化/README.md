# 前端性能优化

产品性能优化方案：

- HTTP 网络层优化
- 代码编译层优化
- 代码运行层优化 html/css + javascript + vue +react
- 安全优化 xss + csrf
- 数据埋点及性能监控
  所有的渲染都必须找 CRP(Critical Rendering Path)关键渲染路径。必须知道每个步骤都经历了什么，才能对症下药进行渲染。

## 从输入 URL 地址到看到页面，中间都经历了什么？

这是面试最长问的问题，也是 CRP 的核心所在。因此，解决这个问题就显得很重要了。
![url](https://ftp.bmp.ovh/imgs/2021/03/3fb8fa5db1260258.png)
如上图所示：我们可以先笼统地回复个大概过程：客户端输入 url 地址，会首先经过 DNS 服务器进行 DNS 解析，通过域名系统，找到对应的服务器 ip 地址，然后再找到服务器下对应的端口去获取资源，然后返回给客户端。客户端拿到的就是各种 html 文本字符串。浏览器通过渲染线程自上而下进行解析，最终生成页面。
但是，上面的答复太过笼统了，面试官肯定不满意，因此我们需要详细了解每个过程。

### 第一步：URL 解析

#### 地址解析

![URL组成](https://ftp.bmp.ovh/imgs/2021/03/32662782878ca100.png)

##### 协议

协议就是用来传输东西的，类似于快递员。传输的东西不同就用不同的传输协议，就像发送的东西不同，用不同类型的快递员。传输文本或者超文本的东西比如字节可以使用 http/https，传输文件可以使用 ftp。

##### 域名

域名是用于去查找对应的服务器

##### 端口号

端口号是用于区分服务器上的不同服务(每个服务其实简单理解就是应用或者说一个项目)

##### 请求资源的文件路径

找到了对应的服务器，接下来就是去服务器下获取对应的资源文件。比如 html,js 或者 css 文件。

#### 编码

为什么需要对域名进行编码了？我们查看一下下面的请求：

```js
http://www.baidu.com?from=http://www.qq.com&name=哈哈哈
```

后面的 from 参数也会被当做是一个 http 请求，事实上他只是一个携带的参数,另外如果我们传递的参数是个中文，可能就会出现乱码。因此，我们需要给 url 地址后面的传参进行编码和解码。常见的编码和解码方式如下：

- encodeURI/decodeURI:编码整个 URL(处理 URL 中的中文)
- encodeURIComponent/decodeURIComponent 编码 URL 中间号传递的信息。

### 第二步：缓存检查

这里说的缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。
第一次加载页面，都没有缓存，直接从服务器获取信息，然后把获取的信息缓存到客户端。
第二次加载页面时，首先看本地是否有缓存，有缓存且没有失效就不从服务器获取了，直接本地缓存获取即可。

#### 缓存位置

- Memory Cache：内存缓存(内存条)
- Disk Cache: 硬盘缓存(物理内存);
  从内存中获取缓存最快，但是 memory cache 是 session 级别的缓存，关闭浏览器之后就没有了。
  打开网页，查找 disk cache 中是否有匹配，如有则使用，如没有则发送网络请求。
  普通刷新(F5)：因 TAB 没关闭，因此 memory cache 是可用的，会被优先使用，其次才是 disk cache。
  强制刷新(ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有`Cache-control:no-cache`，服务器直接返回 200 和最新内容。

#### 强缓存

**Expires/Cache-Control**

> 浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的。

- `Expires`：缓存过期时间，用来指定资源到期的时间(HTTP/1.0)。由于这种时间跟本地的时间设置有关，因此可能修改本地时间导致资源永远不过期或者一直过期，因此存在弊端。
- `Cache-Control`:cache-control:max-age=2592000，第一次拿到资源后的 2592000 秒内(30 天)，再次发送请求，读取缓存中的信息(HTTP/1.1)。由于读取的始终是先对于第一次获取资源的时间，不依赖本地时间，因此比较靠谱。
- 两者同时存在的话，优先使用靠谱的`Cache-Control`。如下图所示：
  ![](https://ftp.bmp.ovh/imgs/2021/03/ce78393997611996.jpg)

**强缓存的流程**
![强缓存](https://ftp.bmp.ovh/imgs/2021/03/c38b6856aacdf56e.png)

1. 浏览器会首先从缓存中获取资源信息，判断是否有缓存，如果有缓存，就获取该缓存资源的 header 中的信息，根据 response header 中的 expires 和 cache-control 来判断缓存是否过期，如果没有过期就直接从缓存中获取资源。
2. 如果缓存中没有找到资源或者资源过期了，那么就重新发送新的 HTTP 请求，然后服务器端返回请求的资源，以及缓存字段，Cache-Control 或者 Expires。
3. 浏览器获取到新的资源以后，将资源和缓存标识都会保存在浏览器中。方便下次请求直接从缓存中获取。

**因此：强缓存的特点：**

- 本地有缓存，可以直接从本地获取，不需要向服务器发送请求
- 强缓存是服务器端设置的，浏览器只是进行保存。

html 页面一般是不设置强缓存的，因为所有的资源都是放在 html 上，防止服务器端更新文件后，客户端获取的还是本地缓存中的页面，这样页面不能及时更新。一般强缓存用于`css/js`等静态文件。
但是对于 css/js 也是存在这个问题的，如果 css 资源发生了更新，但是本地有缓存就使用了本地的了，因此我们通常也会做出处理：

1. 如果服务器有更新，首先页面会更新(返回的 html 字符串)
2. 只要每次有 css/js 更新等，我们在请求 css/js 后面设置一个时间戳。

```js
<script
  type="text/javascript"
  src="//j1.xxx/componentsLoader/dist/ComponentsLoader_v20201229143446.js"
></script>
```

在解析时，发现 js 文件后面时间戳发生变化了，那么本地就没有这个缓存的文件了，因此会重新去请求资源。

3. 另外一种方案是基于 webpack，只要资源文件有更新，通过设置 hash 值生成不同文件名字的资源。每次请求的文件名不一致，就不会导致缓存。

#### 协商缓存

我们可以发现强缓存过于强势了，只要本地有缓存就直接从本地拿，完全不管服务器有没有更新，这样导致一些资源不能被缓存，比如 html 文件；或者一些资源缓存了，可能拿到的不是最新的。因此，有没有不那么强势的缓存，会每次询问服务器是否有更新，然后根据是否有更新来判断去哪里取数据。这就是`协商缓存`。协商缓存是强制缓存失效以后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程,而不是像浏览器一样简单粗暴，只要本地有缓存就从本地拿数据。

**Last-Modified/ETag**
![etag-last-modified](https://ftp.bmp.ovh/imgs/2021/03/725f0128fcda7dc2.jpg)
![协商缓存](https://ftp.bmp.ovh/imgs/2021/03/d385c25e3cf25eb7.png)
协商缓存也是主要涉及到两对属性字段，都是成对出现的。

1. 第一次请求的时候，服务器会返回资源和`Last-Modified`和`ETag`两个字段。

## 第三步：DNS 解析

### DNS 服务器

DNS 服务器就是用来将域名解析成对应的 ip 地址，由于互联网中主机非常多，因此 DNS 服务器肯定也不止一台，DNS 服务器同样根据域名的分类进行分类，分成了根域名服务器，顶级域名服务器和权限域名服务器。另外，还有本地域名服务器。

域名服务器：

- 根域名服务器：只有顶级域名服务器的 ip 地址信息。
- 顶级域名服务器：负责管理该顶级域名服务器注册的所有二级域名。比如找到了.com 服务器，就可以找到所有的 xxx.com 服务器。
- 权限域名服务器:负责一个区的域名服务器。
- 本地域名服务器：当一个主机发出 DNS 查询请求时，这个查询请求报文就发给本地域名服务器。

### 域名解析过程

域名解析过程主要有两种方式，一种是**递归查询**，一种是**迭代查询**。

#### 递归查询

递归查询就是靠别人：比如向本地服务器查询，本地服务器没有，就寻求根服务器的帮助，根服务器找到顶级域名服务器，如果域名还没有解析完成，那么顶级域名服务器就需要靠权限域名服务器的帮助，最终依次下来解析整个域名。
主机 -> 本地域名服务器 -> 根域名服务器 -> 顶级域名服务器 ->权限域名服务器。最终返回 ip 地址就是相反的顺序，从
权限域名服务器得到的->顶级域名服务器 -> 根域名服务器 -> 本地域名服务器 ->主机

以`www.kaoyan.com.`域名为例：

1. 主机访问这个网址时，首先向本地域名服务器(一般是离主机最近的域名服务器，又称为默认域名服务器)发送请求，如果是第一次访问，本地域名服务器没有当前域名的 DNS，那么它就会向根域名发送查询：
2. 根域名服务器只有顶级域名服务器的 ip 地址，这时候它就会把 com(当前域名的顶级域名)的 ip 地址发送给权限域名服务器。
3. 权限域名服务器会摘到对应的区比如`www.kaoyan`这个区。然后找到对应的服务器。
4. 再按照相反的顺序返回 ip 地址。

#### 迭代查询

**迭代查询就是靠自己**（这里的自己就是本地域名服务器）。
主机 -> 本地域名服务器 -> 根域名服务器

1. 主机访问这个网址时，首先向本地域名服务器(一般是离主机最近的域名服务器，又称为默认域名服务器)发送请求，如果是第一次访问，本地域名服务器没有当前域名的 DNS，那么它就会向根域名发送查询，顶级域名还没有查询到，但是它会告诉你你去找 com 这个顶级域名进行查找。
2. 本地域名就会去找相对应的顶级域名服务器，如果顶级域名服务器也不知道域名对应的 ip 地址，那么他就会告诉本地域名服务器去找哪个权限域名服务器。
3. 本地域名继续向权限域名服务器进行查找。知道找到为止。

![域名解析的两种方式](https://ftp.bmp.ovh/imgs/2021/03/6abe15ac32f25858.png)
如上图所示，我们可以发现要查找一个服务器的 ip 地址是非常繁琐的一件事，需要经历多次递归和迭代。因此引入了高速缓存。

#### 高速缓存

将访问过的网站的域名和 DNS 解析信息存储在本地域名服务器中，当再次访问这个域名时只需要从本地域名服务器进行获取即可。

1. 如果直接有这个域名的完整的 DNS，那么可以直接返回。
2. 如果找不到完整的 ip 地址，但是本地域名服务器保存了.com 顶级域名服务器的地址，那么也可以减少本地域名服务器向跟服务器发送的请求。
3. 同理它还可以保存权限域名服务器的信息，减少向顶级域名的请求。

4. 为了保持高速缓存的信息正确，会对本地域名服务器定时更新。
5. 处理对本地域名服务器进行 DNS 缓存，主机也会在第一次启动的时候，向本地域名服务器发送请求，获取域名和对应的 ip 信息的数据库，存储在主机的高速缓存中。因此，要访问一个网站，要经过的顺序是：
   本机的高速缓存查找 DNS 信息 -> 本地服务器的高速缓存查找 DNS 信息，然后才是向根服务器,顶级域名服务器一级权限域名服务器发起 DNS 解析请求。

#### 优化

每一次 DNS 解析时间预计在 20~120ms 之间，因此需要对这个解析过程进行优化：

- 减少 DNS 请求次数(基本上没用)
  一个项目中，尽可能只访问相同服务器，不要访问过多的服务器和域名。但是项目中基本上不会这么做。
  因为在项目中为了更好的优化，我们往往会部署多个服务器，组成服务器集群。
  ![拆分服务器](https://ftp.bmp.ovh/imgs/2021/03/3c7a19764a9922c4.png)
  我们可以查看以下百度首页的服务器数量，每一个项目部署成一个服务器。
  ![服务器数量](https://ftp.bmp.ovh/imgs/2021/03/874f9fae49923b05.png)
  (ps:这也是前端经常面临跨域的原因，静态资源的服务器和数据库等资源的服务器不在一台服务器上)
  服务器拆分的优势：

  1. 资源的合理利用。将项目部署到多台服务器上，有利于资源的合理利用，比如静态资源就可以部署在小一点的服务器上，音视频资源消耗大，可以部署在大的服务器上。
  2. 抗压能力加强
  3. 提高 HTTP 并发。如果同一台服务器最高的并发数一般为 6~7，如果分开成多个服务器，那么每台服务器都可以有 6~7 个并发，最终提高了整个项目的并发数。

- DNS 预解析(DNS Prefetch)
  DNS 预解析就是在页面加载时就开始异步解析 DNS，等到请求资源时，需要通过域名进行 DNS 解析时，此时 DNS 已经解析完毕了，这样的话就节省了 DNS 解析的时间，相当于利用浏览器的多线程同时做多件事。我们可以查看以下京东的 DNS 预解析。
  ![DNS预解析](https://ftp.bmp.ovh/imgs/2021/03/694278c15a27c11c.png)

## 第四步：TCP 三次握手

主机通过 ip 找到了对应的服务器，那么就需要跟服务器建立连接，

为什么不是两次握手或者四次握手?

## 第五步：数据传输

HTTP 报文：

- 请求报文
- 响应报文
  响应状态码:

## 第六步：TCP 四次挥手

为什么连接时候是三次请求，断开连接需要四次请求？这是因为服务器准备数据需要时间，但是它不能一直让客户端等到数据准备好以后，再把数据和断开连接的请求一起发送过去，因此，他会先把数据返回给客户端，同时确认收到断开连接的请求，然后再发送一遍断开连接的请求，也就是说服务器端比建立连接时多发送了一次请求。因此是四次挥手。

由于每次建立连接，断开连接都需要经历三次握手，四次挥手比较繁琐，因此在 http/1.1 时候，新增了 keep-alive 字段用于保持长连接。

## HTTP1.0 和 HTTP1.1 的一些区别

- 缓存处理，HTTP1.0 中主要使用 Last-Modified，Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略：ETag，Cache-Control…

- 带宽优化及网络连接的使用，HTTP1.1 支持断点续传，即返回码是 206（Partial Content）

- 错误通知的管理，在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除…

- Host 头处理，在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）

- 长连接，HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点

## HTTP2.0 和 HTTP1.X 相比的新特性

新的二进制格式（Binary Format），HTTP1.x 的解析是基于文本，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合，基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮

header 压缩，HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 encoder 来减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小

服务端推送（server push），例如我的网页有一个 sytle.css 的请求，在客户端收到 sytle.css 数据的同时，服务端会将 sytle.js 的文件推送给客户端，当客户端再次尝试获取 sytle.js 时就可以直接从缓存中获取到，不用再发请求了

**多路复用：**

- HTTP/1.0 每次请求响应，建立一个 TCP 连接，用完关闭
- HTTP/1.1 「长连接」 若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞。
- HTTP/2.0 「多路复用」多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行。

## 性能优化汇总

-     1.利用缓存
-       + 对于静态资源文件实现强缓存和协商缓存（扩展：文件有更新，如何保证及时刷新？）
-       + 对于不经常更新的接口数据采用本地存储做数据缓存（扩展：cookie / localStorage / vuex|redux 区别？）
-     2.DNS优化
-       + 分服务器部署，增加HTTP并发性（导致DNS解析变慢）
-       + DNS Prefetch
-     3.TCP的三次握手和四次挥手
-       + Connection:keep-alive
-     4.数据传输
-       + 减少数据传输的大小
-         + 内容或者数据压缩（webpack等）
-         + 服务器端一定要开启GZIP压缩（一般能压缩60%左右）
-         + 大批量数据分批次请求（例如：下拉刷新或者分页，保证首次加载请求数据少）
-       + 减少HTTP请求的次数
-         + 资源文件合并处理
-         + 字体图标
-         + 雪碧图 CSS-Sprit
-         + 图片的BASE64
-       + ......
-     5.CDN服务器“地域分布式”
-     6.采用HTTP2.0
- ==============
- 网络优化是前端性能优化的中的重点内容，因为大部分的消耗都发生在网络层，尤其是第一次页面加载，如何减少等待时间很重要“减少白屏的效果和时间”
-     + LOADDING 人性化体验
-     + 骨架屏：客户端骨屏 + 服务器骨架屏
-     + 图片延迟加载
-     + ....
