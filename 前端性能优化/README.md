# 前端性能优化
产品性能优化方案：
- HTTP网络层优化
- 代码编译层优化
- 代码运行层优化 html/css + javascript + vue +react
- 安全优化  xss + csrf
- 数据埋点及性能监控
所有的渲染都必须找CRP(Critical Rendering Path)关键渲染路径。必须知道每个步骤都经历了什么，才能对症下药进行渲染。



## 从输入URL地址到看到页面，中间都经历了什么？
这是面试最长问的问题，也是CRP的核心所在。因此，解决这个问题就显得很重要了。
![url](https://ftp.bmp.ovh/imgs/2021/03/3fb8fa5db1260258.png)
如上图所示：我们可以先笼统地回复个大概过程：客户端输入url地址，会首先经过DNS服务器进行DNS解析，通过域名系统，找到对应的服务器ip地址，然后再找到服务器下对应的端口去获取资源，然后返回给客户端。客户端拿到的就是各种html文本字符串。浏览器通过渲染线程自上而下进行解析，最终生成页面。
但是，上面的答复太过笼统了，面试官肯定不满意，因此我们需要详细了解每个过程。

### 第一步：URL解析
#### 地址解析
![URL组成](https://ftp.bmp.ovh/imgs/2021/03/32662782878ca100.png)

##### 协议
协议就是用来传输东西的，类似于快递员。传输的东西不同就用不同的传输协议，就像发送的东西不同，用不同类型的快递员。传输文本或者超文本的东西比如字节可以使用http/https，传输文件可以使用ftp。

##### 域名
域名是用于去查找对应的服务器

##### 端口号
端口号是用于区分服务器上的不同服务(每个服务其实简单理解就是应用或者说一个项目)


##### 请求资源的文件路径
找到了对应的服务器，接下来就是去服务器下获取对应的资源文件。比如html,js或者css文件。


#### 编码
为什么需要对域名进行编码了？我们查看一下下面的请求：
```js
http://www.baidu.com?from=http://www.qq.com&name=哈哈哈
```
后面的from参数也会被当做是一个http请求，事实上他只是一个携带的参数,另外如果我们传递的参数是个中文，可能就会出现乱码。因此，我们需要给url地址后面的传参进行编码和解码。常见的编码和解码方式如下：
- encodeURI/decodeURI:编码整个URL(处理URL中的中文)
- encodeURIComponent/decodeURIComponent编码URL中间号传递的信息。


### 第二步：缓存检查
这里说的缓存是指浏览器（客户端）在本地磁盘中对访问过的资源保存的副本文件。
第一次加载页面，都没有缓存，直接从服务器获取信息，然后把获取的信息缓存到客户端。
第二次加载页面时，首先看本地是否有缓存，有缓存且没有失效就不从服务器获取了，直接本地缓存获取即可。

#### 缓存位置
* Memory Cache：内存缓存(内存条)
* Disk Cache: 硬盘缓存(物理内存);
从内存中获取缓存最快，但是memory cache是 session 级别的缓存，关闭浏览器之后就没有了。
打开网页，查找disk cache中是否有匹配，如有则使用，如没有则发送网络请求。
普通刷新(F5)：因TAB没关闭，因此memory cache是可用的，会被优先使用，其次才是disk cache。
强制刷新(ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有`Cache-control:no-cache`，服务器直接返回200和最新内容。


#### 强缓存

**Expires/Cache-Control**
> 浏览器对于强缓存的处理：根据第一次请求资源时返回的响应头来确定的。
* `Expires`：缓存过期时间，用来指定资源到期的时间(HTTP/1.0)。由于这种时间跟本地的时间设置有关，因此可能修改本地时间导致资源永远不过期或者一直过期，因此存在弊端。
* `Cache-Control`:cache-control:max-age=2592000，第一次拿到资源后的2592000秒内(30天)，再次发送请求，读取缓存中的信息(HTTP/1.1)。由于读取的始终是先对于第一次获取资源的时间，不依赖本地时间，因此比较靠谱。
* 两者同时存在的话，优先使用靠谱的`Cache-Control`。如下图所示：
![](https://ftp.bmp.ovh/imgs/2021/03/ce78393997611996.jpg)

**强缓存的流程**
![强缓存](https://ftp.bmp.ovh/imgs/2021/03/c38b6856aacdf56e.png)

1. 浏览器会首先从缓存中获取资源信息，判断是否有缓存，如果有缓存，就获取该缓存资源的 header 中的信息，根据 response header 中的 expires 和 cache-control 来判断缓存是否过期，如果没有过期就直接从缓存中获取资源。
2. 如果缓存中没有找到资源或者资源过期了，那么就重新发送新的HTTP请求，然后服务器端返回请求的资源，以及缓存字段，Cache-Control或者Expires。
3. 浏览器获取到新的资源以后，将资源和缓存标识都会保存在浏览器中。方便下次请求直接从缓存中获取。

**因此：强缓存的特点：**
* 本地有缓存，可以直接从本地获取，不需要向服务器发送请求
* 强缓存是服务器端设置的，浏览器只是进行保存。

html页面一般是不设置强缓存的，因为所有的资源都是放在html上，防止服务器端更新文件后，客户端获取的还是本地缓存中的页面，这样页面不能及时更新。一般强缓存用于`css/js`等静态文件。
但是对于css/js也是存在这个问题的，如果css资源发生了更新，但是本地有缓存就使用了本地的了，因此我们通常也会做出处理：
1. 如果服务器有更新，首先页面会更新(返回的html字符串)
2. 只要每次有css/js更新等，我们在请求css/js后面设置一个时间戳。
```js

<script type="text/javascript" src="//j1.xxx/componentsLoader/dist/ComponentsLoader_v20201229143446.js"></script>
```
在解析时，发现js文件后面时间戳发生变化了，那么本地就没有这个缓存的文件了，因此会重新去请求资源。
3. 另外一种方案是基于webpack，只要资源文件有更新，通过设置hash值生成不同文件名字的资源。每次请求的文件名不一致，就不会导致缓存。


#### 协商缓存
我们可以发现强缓存过于强势了，只要本地有缓存就直接从本地拿，完全不管服务器有没有更新，这样导致一些资源不能被缓存，比如html文件；或者一些资源缓存了，可能拿到的不是最新的。因此，有没有不那么强势的缓存，会每次询问服务器是否有更新，然后根据是否有更新来判断去哪里取数据。这就是`协商缓存`。协商缓存是强制缓存失效以后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程,而不是像浏览器一样简单粗暴，只要本地有缓存就从本地拿数据。

**Last-Modified/ETag**
![etag-last-modified](https://ftp.bmp.ovh/imgs/2021/03/725f0128fcda7dc2.jpg)
![协商缓存](https://ftp.bmp.ovh/imgs/2021/03/d385c25e3cf25eb7.png)
协商缓存也是主要涉及到两对属性字段，都是成对出现的。
1. 第一次请求的时候，服务器会返回资源和`Last-Modified`和`ETag`两个字段。其中