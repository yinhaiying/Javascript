## 浏览器的底层渲染机制

![](https://ftp.bmp.ovh/imgs/2021/03/f221ec38ed0a1ab7.png)
如上图所示：客户端输入网址，向百度发送请求，服务端返回的是一大串的html，然后浏览器将其解析展示成我们看到的页面了。那么到底是如何解析的了？也就是浏览器到底是如何渲染页面的，这就是我们今天学习的重点。



## 加载资源的同步异步
客户端从服务器获取到需要渲染的页面的源代码后，做了哪些事情？
**开辟一个GUI渲染线程，自上而下解析代码，最后绘制页面。**
![](https://ftp.bmp.ovh/imgs/2021/03/034a3d1eab5c5913.jpg)
如上图所示，GUI渲染线程自上而下进行解析，会碰到各种标签，比如style,link,script等，
这些自上而下渲染解析代码有些是同步的，但是有些操作也是异步的，比如：
 1. 遇到CSS资源的加载。
    * 遇到的是<style></style>内联样式。同步地交给GUI渲染线程解析
    * 遇到的是<link></link>外联样式。
       =>异步地进行处理，开辟一个新的http网络请求线程。(注意：同一个源下，根据不同的浏览器，最多只允许同时开辟4~7个HTTP线程，也就是“HTTP的并发数”)。
       =>不等待资源信息请求回来，GUI渲染线程继续往下渲染。
       =>GUI渲染线程同步操作完成后，再把基于Http网络线程请求回来的资源文件进行解析渲染。
    * 遇到@import "导入式样式"。
       => "同步"地开辟一个新的HTTP网络请求线程，去请求资源文件
       => 但是在资源文件没有请求回来之前，GUI渲染线程会被“阻塞”，不允许其继续向下渲染。
       => @import是阻碍GUI渲染线程渲染，因此，@import一般在项目中很少使用。

2. 遇到<script></script>资源的请求
   => 默认都是同步的：必须基于HTTP网络线程，把资源请求回来之后，并且交给“JS”渲染线程渲染解析完成后，GUI渲染线程才能继续向下渲染。
   => script默认也是阻碍GUI渲染机制向下渲染。
   => async属性实现异步渲染。遇到<script async></script>首先也是会开辟一个HTTP网络线程去请求加载资源文件，但是与此同时GUI渲染线程也会继续向下渲染。把默认的同步改成异步。但是一旦资源请求回来后，会中断GUI的渲染，会先将请求回来的资源文件进行解析渲染完成，才会继续后面的代码的解析渲染。
   => defer属性：遇到<script defer></script>首先也是会开辟一个HTTP网络线程去请求加载资源文件,但是与此同时GUI渲染线程也会继续向下渲染。但是`defer`是在GUI渲染完成之后，也就是同步代码执行完毕之后，才会渲染解析defer请求回来的资源。
3. 遇到<img><audio>等音视频资源。
   => 默认都是异步的，也会发送HTTP网络线程去请求加载对应的资源文件，不阻碍GUI的渲染，当GUI渲染完成之后，才会将请求回来的资源进行解析。

## 页面渲染的步骤：
1. DOM TREE(DOM树)：自上而下渲染完成页面，整理好整个页面的DOM结构关系，生成DOM树，如下图所示。(此时那些异步请求，比如Link样式的加载还等待解析执行)
![DOM树](https://ftp.bmp.ovh/imgs/2021/03/09771e428d17a649.png)
2. CSSOM TREE(css样式树)：当link等所有的样式资源请求回来后，按照引入CSS的顺序依次渲染CSS代码(因为后面的CSS会覆盖前面设置的CSS)，生成样式树，如下图所示。
![CSSOM树](https://ftp.bmp.ovh/imgs/2021/03/0b1fe694e9bfc1a7.jpg)
3. RENDER TREE(渲染树):等待样式树生成以后，会将DOM树和样式树合并在一起，形成渲染树（设置display:none的元素不会展示在渲染树中）。
![渲染树](https://ftp.bmp.ovh/imgs/2021/03/ba794f3ca7b49157.png)
4. Layout布局/回流/重排：根据生成的render树，计算他们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流=> 布局(layout)或者重排(reflow)。
5. 分层处理：按照层级定位分层处理，每一个层级都会详细规划出具体的绘制步骤。我们在编写CSS的时候，在定位时，经常会用到z-index，将页面内容分成不同的层级，因此浏览器渲染时也会进行分层处理，每一个层级给出具体的绘制步骤。
![分层处理](https://ftp.bmp.ovh/imgs/2021/03/a6bacc629b87d943.jpg)
6. Painting绘制：按照每一个层级给出的绘制步骤，进行页面的绘制。


## 前端性能优化 CRP：关键渲染步骤

1. 生成`DOM`树：减少DOM层级嵌套，不要使用非标准标签(遇到非标准标签需要进行额外处理)。
2. 生成`CSSOM`树：
     - 尽可能不要使用@import，因为@import会阻塞GUI渲染。
     - 如果CSS样式比较少，尽可能使用style内嵌样式,尤其是移动端开发。
     - 如果使用link,尽可减少link的数量，将所有的样式资源合并成一个CSS，减少HTTP的请求，以及渲染CSSOM树的时   候，也不需要再计算依赖关系。
     - css选择器的链短一些，因为CSS选择器的渲染是从右到左的，越长查找时间越长
     - 把link等导入css的操作放到Head中，(目的是一加载页面就开始请求资源，同时GUI去生成DOM树，减少等待时间。“CSS的预加载”)。
4. 对于`script`加载的js资源
   对于script，尽可能放置在页面底部，防止其阻塞GUI的渲染；对于部分script需要使用`async`和`defer`。
   async是不管js依赖关系的，谁先回来谁先执行，因此使用async时，不要依赖其他代码。
   defer不一样，和link一样，需要等待所有资源回来之后，按照依赖关系依次渲染执行。

5. 对于img图片
   - 最好的方式就是`懒加载`。第一次加载页面的时候不要加载请求图片，哪怕它是异步的，但是也占据了HTTP并发的数量，尤其是页面中图片一般会比较多，这时候会导致其他资源延后加载。
   - 使用base64：不用去请求加载图片，base64码不需要再进行编码，基本上代表的就是图片，因此页面渲染速度会很快(慎用，但是在webpack工程化中可以使用，因为它基于file-loader进行了优化，只有编译后才会转成base64)。

6. 生成render树：不需要进行优化。
7. Layout/Painting：重要的优化手段（减少DOM的回流和重排）
   - 第一次加载页面的时候，必然会有一次重流和重绘。
   - 触发回流操作后，必然会触发重绘。如果只是单纯的重绘，则不会触发回流。因此，性能优化点重点都在回流上，重绘是不可避免的。
   -为什么说操作DOM消耗性能：主要原因就是DOM的回流。
   **回流**：就是把layout的计算过程重新计算一遍。layout就是用来计算确切位置和大小。因此，
        * 元素再视口中的大小和位置发生了变化，就会触发回流；
        * 元素的删除和新增(以及基于display控制显示隐藏)；
        * 浏览器视口大小发生变化
        这些操作都需要浏览器重新计算每个元素在视口中的位置和大小，也就是重新layout/reflow。

**修改元素的样式触发回流**
    ```html
    box.style.width = "100px";
    box.style.height = "100px";
    box.style.position = "absolute";
    box.style.top = "100px";
    ```
当代浏览器的渲染队列机制：在当前上下文操作中，遇到一行修改样式的代码，并没有立即通知浏览器渲染，而是把其防止在渲染队列中，接下来查看是否还有修改样式的代码，如果有继续放置在渲染队列中，...一直到再也没有修改样式的代码或者**遇到一行获取样式的代码**，这样都会刷新浏览器的渲染机制队列（也就是把现在渲染队列中修改样式的操作，统一告诉浏览器渲染，这样的话就会只触发一次回流操作）
  **一. 减少DOM回流的方法——针对修改样式比如大小**：
  1. 样式的分离读写：把修改样式和获取样式代码分离开，这样的话修改样式就只会统一触发一次回流。
  2. 统一修改样式：比如使用class或者style.cssText。避免在修改样式中插入获取样式。
  3. 缓存布局信息：
  ```js
  box.style.width = box.offsetWidth + 10 + "px";   // 获取操作和设置操作混在一起，会触发回流
  box.style.height = box.offsetHeight + 10 + "px"; // 获取操作和设置操作混在一起，会触发回流
  ```
  修改为：
  ```js
  let w = box.offsetWidth;
  let h = box.offsetHeight;  
  box.style.width = w + 10 + "px";  // 没有获取了，不会再触发回流了。
  box.style.height = h + 10 + "px";
  ```

 **二. 减少DOM回流的方法——针对新增元素，删除元素等**：
 ```js
 let arr = ["张三","李四","王五"];
 // 循环几次就会触发几次回流
 arr.forEach((item) => {
     let span = document.createElement("span");
     span.innerText = item;
     document.appendChild(span);
 })
 ```
 这种操作DOM，操作几次就会触发几次回流，因此最好的办法就是将DOM操作合并，比如使用模板字符串：
 **模板字符串**:..
 ```js
 let str = ``;
 arr.forEach((item) => {
     str += `<span>${item}</span>`
 });
 document.body.innerHTML += str;  // 使用+=可能会导致原来的内容绑定的事件失效
 ```
 但是模板字符串存在一个问题，可能会因为页面中把原始容器内容变成字符串和新的字符串拼接，导致原始容器内的元素绑定的一些事件失效。更好的办法是使用文档碎片，文档碎片用于临时存放dom信息，最后一次性添加。
 **文档碎片：**
 ```js
 let arr = ["张三","李四","王五"];
 let frag = document.createDocumentFragment();
 arr.forEach((item) => {
     let span = document.createElement("span");
     span.innerText = item;
     flag.appendChild(span);
 })
 document.body.appendChild(flag);   // 只引发一次回流
 flag = null; 
 ```

**三. 把动画等频发样式改变的操作，运用到position:fixed/absolute身上——利用分层机制**
这是因为Position会触发分层(脱离文档流)，回流时只会触发当前层的重新绘制。如果只改变一个层面上的大小和位置，
浏览器回流和重绘的速度会加快很多。

**四：修改元素的transform/opacity(filters)**
修改这些样式时不会引发DOM的回流，因为他们会开启浏览器的硬件加速，弊端就是消耗浏览器的内存。